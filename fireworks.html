<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fireworks Shader</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">Fireworks Shader â€¢ Click to reset</div>

    <script>
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            
            uniform vec2 iResolution;
            uniform float iTime;
            
            #define PI 3.141592653589793
            #define EXPLOSION_COUNT 8.
            #define SPARKS_PER_EXPLOSION 128.
            #define EXPLOSION_DURATION 20.
            #define EXPLOSION_SPEED 5.
            #define EXPLOSION_RADIUS_THESHOLD .06
            
            // Hash function by Dave_Hoskins.
            #define MOD3 vec3(.1031,.11369,.13787)
            
            vec3 hash31(float p) {
                vec3 p3 = fract(vec3(p) * MOD3);
                p3 += dot(p3, p3.yzx + 19.19);
                return fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));
            }
            
            void main() {
                vec2 fragCoord = gl_FragCoord.xy;
                float aspectRatio = iResolution.x / iResolution.y;
                vec2 uv = fragCoord / iResolution.y;
                float t = mod(iTime + 10., 7200.);
                vec3 col = vec3(0.); 
                vec2 origin = vec2(0.);
                
                for (float j = 0.; j < EXPLOSION_COUNT; ++j) {
                    vec3 oh = hash31((j + 1234.1939) * 641.6974);
                    origin = vec2(oh.x, oh.y) * .6 + .2; // .2 - .8 to avoid boundaries
                    origin.x *= aspectRatio;
                    // Change t value to randomize the spawning of explosions
                    t += (j + 1.) * 9.6491 * oh.z;
                    
                    for (float i = 0.; i < SPARKS_PER_EXPLOSION; ++i) {
                        // Thanks Dave_Hoskins for the suggestion
                        vec3 h = hash31(j * 963.31 + i + 497.8943);
                        // random angle (0 - 2*PI)
                        float a = h.x * PI * 2.;
                        // random radius scale for spawning points anywhere in a circle
                        float rScale = h.y * EXPLOSION_RADIUS_THESHOLD;
                        // explosion loop based on time
                        if (mod(t * EXPLOSION_SPEED, EXPLOSION_DURATION) > 2.) {
                            // random radius 
                            float r = mod(t * EXPLOSION_SPEED, EXPLOSION_DURATION) * rScale;
                            // explosion spark polar coords 
                            vec2 sparkPos = vec2(r * cos(a), r * sin(a));
                            // fake-ish gravity
                            float poopoo = 0.04;
                            float peepee = (length(sparkPos) - (rScale - poopoo)) / poopoo;
                            sparkPos.y -= pow(peepee, 3.0) * 6e-5;
                            // shiny spark particles
                            float spark = .0002/pow(length(uv - sparkPos - origin), 1.65);
                            // Make the explosion spark shimmer/sparkle
                            float sd = 2. * length(origin-sparkPos);
                            float shimmer = max(0., sqrt(sd) * (sin((t + h.y * 2. * PI) * 20.)));
                            float shimmerThreshold = EXPLOSION_DURATION * .32;
                            // fade the particles towards the end of explosion
                            float fade = max(0., (EXPLOSION_DURATION - 5.) * rScale - r);
                            // mix it all together
                            col += spark * mix(1., shimmer, smoothstep(shimmerThreshold * rScale,
                                (shimmerThreshold + 1.) * rScale , r)) * fade * oh;
                        }
                    }
                }
                
                // evening-sh background gradient
                col = max(vec3(.1), col);
                col += vec3(.12, .06, .02) * (1.-uv.y);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Initialize WebGL
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Create shaders
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        // Create program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            
            return program;
        }

        // Setup
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);
        
        // Create buffer for full-screen quad
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        
        // Get attribute and uniform locations
        const positionLocation = gl.getAttribLocation(program, 'position');
        const resolutionLocation = gl.getUniformLocation(program, 'iResolution');
        const timeLocation = gl.getUniformLocation(program, 'iTime');
        
        // Animation state
        let startTime = Date.now();
        let timeOffset = 0;
        
        // Handle window resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        window.addEventListener('resize', resize);
        resize();
        
        // Handle click to reset
        canvas.addEventListener('click', () => {
            startTime = Date.now();
            timeOffset = Math.random() * 100;
        });
        
        // Render loop
        function render() {
            const currentTime = (Date.now() - startTime) / 1000 + timeOffset;
            
            // Clear canvas
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Use shader program
            gl.useProgram(program);
            
            // Set uniforms
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, currentTime);
            
            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }
        
        // Start rendering
        render();
    </script>
</body>
</html>
